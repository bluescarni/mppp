if(MPPP_BENCHMARK_BOOST)
  find_package(Boost 1.55.0 REQUIRED)
endif()

function(ADD_MPPP_BENCHMARK arg1)
    add_executable(${arg1} ${arg1}.cpp)
    target_link_libraries(${arg1} mp++)
    if(MPPP_BENCHMARK_BOOST)
      target_link_libraries(${arg1} Boost::boost)
      target_compile_options(${arg1} PRIVATE "-DMPPP_BENCHMARK_BOOST")
    endif()
    target_include_directories(${arg1} PRIVATE $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}>)
    target_compile_options(${arg1} PRIVATE "$<$<CONFIG:DEBUG>:${MPPP_CXX_FLAGS_DEBUG}>" "$<$<CONFIG:RELEASE>:${MPPP_CXX_FLAGS_DEBUG_RELEASE}>")
    if(MPPP_COMPILER_SUPPORTS_CONCEPTS)
      # NOTE: the idea here is that we want to use C++14 if the compilers supports
      # concepts (as variable concepts are essentially template variables).
      set_property(TARGET ${arg1} PROPERTY CXX_STANDARD 14)
    else()
      set_property(TARGET ${arg1} PROPERTY CXX_STANDARD 11)
    endif()
    set_property(TARGET ${arg1} PROPERTY CXX_STANDARD_REQUIRED YES)
    set_property(TARGET ${arg1} PROPERTY CXX_EXTENSIONS NO)
endfunction()

ADD_MPPP_BENCHMARK(bench_dot_product_1)
ADD_MPPP_BENCHMARK(bench_dot_product_2)
ADD_MPPP_BENCHMARK(bench_dot_product_3)
ADD_MPPP_BENCHMARK(bench_vec_mul_1)
ADD_MPPP_BENCHMARK(bench_vec_mul_2)
ADD_MPPP_BENCHMARK(bench_vec_mul_3)
ADD_MPPP_BENCHMARK(bench_sort_1)

if(MPPP_WITH_MPFR)
  ADD_MPPP_BENCHMARK(real_vec_mul)
endif()
