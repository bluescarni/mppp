
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Multiprecision float tutorial &#8212; mp++ 0.27 documentation</title>
    
  <!-- Loaded before other Sphinx assets -->
  <link href="_static/styles/theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">
<link href="_static/styles/pydata-sphinx-theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">

    
  <link rel="stylesheet"
    href="_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" href="_static/styles/sphinx-book-theme.css?digest=5115cc725059bd94278eecd172e13a965bf8f5a9" type="text/css" />
    <link rel="stylesheet" type="text/css" href="_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf">

    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/scripts/sphinx-book-theme.js?digest=9c920249402e914e316237a7dbc6769907cce411"></script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Multiprecision complex numbers tutorial" href="tutorial_complex.html" />
    <link rel="prev" title="Quadruple-precision complex numbers tutorial" href="tutorial_complex128.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="en">
    

    <!-- Google Analytics -->
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="60">
<!-- Checkboxes to toggle the left sidebar -->
<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation" aria-label="Toggle navigation sidebar">
<label class="overlay overlay-navbar" for="__navigation">
    <div class="visually-hidden">Toggle navigation sidebar</div>
</label>
<!-- Checkboxes to toggle the in-page toc -->
<input type="checkbox" class="sidebar-toggle" name="__page-toc" id="__page-toc" aria-label="Toggle in-page Table of Contents">
<label class="overlay overlay-pagetoc" for="__page-toc">
    <div class="visually-hidden">Toggle in-page Table of Contents</div>
</label>
<!-- Headers at the top -->
<div class="announcement header-item noprint"></div>
<div class="header header-item noprint"></div>

    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<!-- Sidebar -->
<div class="bd-sidebar noprint" id="site-navigation">
    <div class="bd-sidebar__content">
        <div class="bd-sidebar__top"><div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="index.html">
      
      
      
      <h1 class="site-logo" id="site-title">mp++ 0.27 documentation</h1>
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..." aria-label="Search the docs ..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item active">
        <ul class="current nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="installation.html">
   Installation
  </a>
 </li>
 <li class="toctree-l1 current active has-children">
  <a class="reference internal" href="tutorial.html">
   Tutorial
  </a>
  <input checked="" class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" type="checkbox"/>
  <label for="toctree-checkbox-1">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul class="current">
   <li class="toctree-l2">
    <a class="reference internal" href="tutorial_prelim.html">
     Preliminaries
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="tutorial_constr.html">
     Construction, conversion and assignment
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="tutorial_io.html">
     Input and output
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="tutorial_numtower.html">
     The numerical tower and type coercion
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="tutorial_commonops.html">
     Common operators
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="tutorial_api.html">
     API overview
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="tutorial_integer.html">
     Integer tutorial
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="tutorial_rational.html">
     Rational tutorial
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="tutorial_real128.html">
     Quadruple-precision float tutorial
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="tutorial_complex128.html">
     Quadruple-precision complex numbers tutorial
    </a>
   </li>
   <li class="toctree-l2 current active">
    <a class="current reference internal" href="#">
     Multiprecision float tutorial
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="tutorial_complex.html">
     Multiprecision complex numbers tutorial
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="tutorial_boost_s11n.html">
     Boost.serialization support
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="tutorial_pybind11.html">
     Extra: integration with pybind11
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="interactive_notebooks.html">
   Interactive notebooks
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" type="checkbox"/>
  <label for="toctree-checkbox-2">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="notebooks/integer_basics.html">
     Integer basics
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="notebooks/integer_formatted_output.html">
     Integer formatted output
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="notebooks/integer_arithmetic.html">
     Integer arithmetic
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="notebooks/integer_comparison.html">
     Integer comparison
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="notebooks/integer_bit_fiddling.html">
     Integer logic and bit fiddling
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="notebooks/integer_s11n.html">
     Integer serialisation
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="notebooks/real_basics.html">
     Real basics
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="reference.html">
   Reference
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" type="checkbox"/>
  <label for="toctree-checkbox-3">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="definitions.html">
     Macros and definitions
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="namespaces.html">
     Namespaces
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="exceptions.html">
     Exceptions
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="concepts.html">
     Common concepts
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="integer.html">
     Multiprecision integers
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="rational.html">
     Multiprecision rationals
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="real128.html">
     Quadruple-precision floats
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="complex128.html">
     Quadruple-precision complex numbers
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="real.html">
     Multiprecision floats
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="complex.html">
     Multiprecision complex numbers
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="utilities.html">
     Utility functions
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="fwd_decl.html">
     Forward declarations
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="benchmarks.html">
   Benchmarks
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-4" name="toctree-checkbox-4" type="checkbox"/>
  <label for="toctree-checkbox-4">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="integer_benchmarks.html">
     Integer benchmarks
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="changelog.html">
   Changelog
  </a>
 </li>
</ul>

    </div>
</nav></div>
        <div class="bd-sidebar__bottom">
             <!-- To handle the deprecated key -->
            
            <div class="navbar_extra_footer">
            Theme by the <a href="https://ebp.jupyterbook.org">Executable Book Project</a>
            </div>
            
        </div>
    </div>
    <div id="rtd-footer-container"></div>
</div>


          


          
<!-- A tiny helper pixel to detect if we've scrolled -->
<div class="sbt-scroll-pixel-helper"></div>
<!-- Main content -->
<div class="col py-0 content-container">
    
    <div class="header-article row sticky-top noprint">
        



<div class="col py-1 d-flex header-article-main">
    <div class="header-article__left">
        
        <label for="__navigation"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="right"
title="Toggle navigation"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-bars"></i>
  </span>

</label>

        
    </div>
    <div class="header-article__right">
<button onclick="toggleFullScreen()"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="bottom"
title="Fullscreen mode"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>

<div class="menu-dropdown menu-dropdown-repository-buttons">
  <button class="headerbtn menu-dropdown__trigger"
      aria-label="Source repositories">
      <i class="fab fa-github"></i>
  </button>
  <div class="menu-dropdown__content">
    <ul>
      <li>
        <a href="https://github.com/bluescarni/mppp"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Source repository"
>
  

<span class="headerbtn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="headerbtn__text-container">repository</span>
</a>

      </li>
      
      <li>
        <a href="https://github.com/bluescarni/mppp/issues/new?title=Issue%20on%20page%20%2Ftutorial_real.html&body=Your%20issue%20content%20here."
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Open an issue"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="headerbtn__text-container">open issue</span>
</a>

      </li>
      
    </ul>
  </div>
</div>

<div class="menu-dropdown menu-dropdown-download-buttons">
  <button class="headerbtn menu-dropdown__trigger"
      aria-label="Download this page">
      <i class="fas fa-download"></i>
  </button>
  <div class="menu-dropdown__content">
    <ul>
      <li>
        <a href="_sources/tutorial_real.rst.txt"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Download source file"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="headerbtn__text-container">.rst</span>
</a>

      </li>
      
      <li>
        
<button onclick="printPdf(this)"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="left"
title="Print to PDF"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="headerbtn__text-container">.pdf</span>
</button>

      </li>
      
    </ul>
  </div>
</div>
<label for="__page-toc"
  class="headerbtn headerbtn-page-toc"
  
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-list"></i>
  </span>

</label>

    </div>
</div>

<!-- Table of contents -->
<div class="col-md-3 bd-toc show noprint">
    <div class="tocsection onthispage pt-5 pb-3">
        <i class="fas fa-list"></i> Contents
    </div>
    <nav id="bd-toc-nav" aria-label="Page">
        <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#construction-and-precision-handling">
   Construction and precision handling
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#precision-propagation">
   Precision propagation
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#move-awareness">
   Move awareness
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#special-functions">
   Special functions
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#constants">
   Constants
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#comparisons">
   Comparisons
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#interacting-with-the-mpfr-api">
   Interacting with the MPFR API
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#serialisation">
   Serialisation
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#user-defined-literals">
   User-defined literals
  </a>
 </li>
</ul>

    </nav>
</div>
    </div>
    <div class="article row">
        <div class="col pl-md-3 pl-lg-5 content-container">
            <!-- Table of contents that is only displayed when printing the page -->
            <div id="jb-print-docs-body" class="onlyprint">
                <h1>Multiprecision float tutorial</h1>
                <!-- Table of contents -->
                <div id="print-main-content">
                    <div id="jb-print-toc">
                        
                        <div>
                            <h2> Contents </h2>
                        </div>
                        <nav aria-label="Page">
                            <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#construction-and-precision-handling">
   Construction and precision handling
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#precision-propagation">
   Precision propagation
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#move-awareness">
   Move awareness
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#special-functions">
   Special functions
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#constants">
   Constants
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#comparisons">
   Comparisons
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#interacting-with-the-mpfr-api">
   Interacting with the MPFR API
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#serialisation">
   Serialisation
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#user-defined-literals">
   User-defined literals
  </a>
 </li>
</ul>

                        </nav>
                    </div>
                </div>
            </div>
            <main id="main-content" role="main">
                
              <div>
                
  <section id="multiprecision-float-tutorial">
<span id="tutorial-real"></span><h1>Multiprecision float tutorial<a class="headerlink" href="#multiprecision-float-tutorial" title="Permalink to this headline">#</a></h1>
<p><a class="reference internal" href="real.html#_CPPv4N4mppp4realE" title="mppp::real"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">real</span></code></a> is a floating-point
class in which the number of digits of precision in the significand can
be set at runtime to any value (limited only by the available
memory).</p>
<p><a class="reference internal" href="real.html#_CPPv4N4mppp4realE" title="mppp::real"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">real</span></code></a> wraps the
<a class="reference internal" href="real.html#_CPPv46mpfr_t" title="mpfr_t"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">mpfr_t</span></code></a> type from the MPFR library,
and it is designed to behave like a standard C++ floating-point type
in which the precision is not a compile-time property of the class,
but rather a runtime property of the class instances.</p>
<section id="construction-and-precision-handling">
<h2>Construction and precision handling<a class="headerlink" href="#construction-and-precision-handling" title="Permalink to this headline">#</a></h2>
<p>The precision of a <a class="reference internal" href="real.html#_CPPv4N4mppp4realE" title="mppp::real"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">real</span></code></a> is measured in the number
of bits in the significand, and it can be set at
construction or changed at a later stage. A default-constructed
<a class="reference internal" href="real.html#_CPPv4N4mppp4realE" title="mppp::real"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">real</span></code></a> will have the smallest possible precision
(see <a class="reference internal" href="real.html#_CPPv4N4mppp13real_prec_minEv" title="mppp::real_prec_min"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">real_prec_min()</span></code></a>), and a value of zero.
When a <a class="reference internal" href="real.html#_CPPv4N4mppp4realE" title="mppp::real"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">real</span></code></a> is constructed from another
numeric type, its precision is automatically deduced so that
the value of the source object is preserved, if possible.
The copy constructor and the copy assignment operator of
<a class="reference internal" href="real.html#_CPPv4N4mppp4realE" title="mppp::real"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">real</span></code></a> copy both the value and the precision,
so that the result of the operation is an exact copy of the source
operand.</p>
<p>Let’s see a few examples:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">real</span><span class="w"> </span><span class="n">x0</span><span class="p">;</span><span class="w">                </span><span class="c1">// x0 is inited to zero with minimum precision.</span>

<span class="n">real</span><span class="w"> </span><span class="n">x1</span><span class="p">{</span><span class="mi">42</span><span class="p">};</span><span class="w">            </span><span class="c1">// x1 is inited to 42, the precision is set to</span>
<span class="w">                        </span><span class="c1">// the bit width of the &#39;int&#39; type</span>
<span class="w">                        </span><span class="c1">// (typically 32).</span>

<span class="n">real</span><span class="w"> </span><span class="n">x2</span><span class="p">{</span><span class="mi">42</span><span class="p">,</span><span class="w"> </span><span class="mi">128</span><span class="p">};</span><span class="w">       </span><span class="c1">// x2 is inited to 42, the precision is set</span>
<span class="w">                        </span><span class="c1">// explicitly to 128 bits.</span>

<span class="n">real</span><span class="w"> </span><span class="n">x3</span><span class="p">{</span><span class="mi">1</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">3</span><span class="n">_q1</span><span class="p">};</span><span class="w">      </span><span class="c1">// x3 is inited from the rational value</span>
<span class="w">                        </span><span class="c1">// &#39;1/3&#39;. The precision is set to the sum</span>
<span class="w">                        </span><span class="c1">// of the bit widths of numerator and</span>
<span class="w">                        </span><span class="c1">// denominator (which will total 128 bits</span>
<span class="w">                        </span><span class="c1">// on most platforms). Because &#39;1/3&#39;</span>
<span class="w">                        </span><span class="c1">// cannot be represented exactly in a binary</span>
<span class="w">                        </span><span class="c1">// floating-point format, x3 will contain</span>
<span class="w">                        </span><span class="c1">// the 128-bit approximation of &#39;1/3&#39;.</span>

<span class="n">real</span><span class="w"> </span><span class="n">x4</span><span class="p">{</span><span class="mi">1</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">3</span><span class="n">_q1</span><span class="p">,</span><span class="w"> </span><span class="mi">256</span><span class="p">};</span><span class="w"> </span><span class="c1">// x4 is inited to the 256-bit</span>
<span class="w">                        </span><span class="c1">// approximation of the rational</span>
<span class="w">                        </span><span class="c1">// value &#39;1/3&#39;.</span>

<span class="n">real</span><span class="w"> </span><span class="n">x5</span><span class="p">{</span><span class="n">x4</span><span class="p">};</span><span class="w">            </span><span class="c1">// x5 is an exact copy (i.e., both</span>
<span class="w">                        </span><span class="c1">// value and precision) of x4.</span>

<span class="n">x5</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x2</span><span class="p">;</span><span class="w">                </span><span class="c1">// x5 is now an exact copy of x2.</span>

<span class="n">x5</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1.25</span><span class="p">;</span><span class="w">              </span><span class="c1">// x5 now contains the value &#39;1.25&#39;,</span>
<span class="w">                        </span><span class="c1">// and its precision is set to the number</span>
<span class="w">                        </span><span class="c1">// of binary digits in the significand of</span>
<span class="w">                        </span><span class="c1">// the C++ &#39;double&#39; type (typically 53).</span>

<span class="c1">// Fetch and print the precision of x2 (i.e., 128).</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">x2</span><span class="p">.</span><span class="n">get_prec</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="sc">&#39;\n&#39;</span><span class="p">;</span><span class="w"></span>

<span class="c1">// Reduce the precision of x2 to 4 bits, while</span>
<span class="c1">// rounding to nearest the original value. I.e.,</span>
<span class="c1">// x2 will end up containing the 4-bit approximation</span>
<span class="c1">// of the value &#39;42&#39;.</span>
<span class="n">x2</span><span class="p">.</span><span class="n">prec_round</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span><span class="w"></span>
<span class="n">assert</span><span class="p">(</span><span class="n">x2</span><span class="p">.</span><span class="n">get_prec</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">4</span><span class="p">);</span><span class="w"></span>
<span class="n">assert</span><span class="p">(</span><span class="n">x2</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">real</span><span class="p">{</span><span class="mi">42</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">});</span><span class="w"></span>

<span class="c1">// Destructively extend the precision of x2</span>
<span class="c1">// to 1024 bits. The value will be set to NaN.</span>
<span class="n">x2</span><span class="p">.</span><span class="n">set_prec</span><span class="p">(</span><span class="mi">1024</span><span class="p">);</span><span class="w"></span>
<span class="n">assert</span><span class="p">(</span><span class="n">x2</span><span class="p">.</span><span class="n">nan_p</span><span class="p">());</span><span class="w"></span>
</pre></div>
</div>
<p>The constructors from string currently always require the
precision to be passed explicitly (this restriction may
be lifted in the future):</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">real</span><span class="w"> </span><span class="n">x0</span><span class="p">{</span><span class="s">&quot;1.1&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">512</span><span class="p">};</span><span class="w">          </span><span class="c1">// x0 is set to the 512-bit approximation</span>
<span class="w">                              </span><span class="c1">// of &#39;1.1&#39;.</span>

<span class="n">real</span><span class="w"> </span><span class="n">x1</span><span class="p">{</span><span class="s">&quot;0x1.5p-1&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">16</span><span class="p">,</span><span class="w"> </span><span class="mi">512</span><span class="p">};</span><span class="w"> </span><span class="c1">// Construction from other bases is also</span>
<span class="w">                              </span><span class="c1">// possible (here base 16 is used).</span>
</pre></div>
</div>
<p>In additions to the <a class="reference internal" href="tutorial_constr.html#tutorial-constr"><span class="std std-ref">constructors</span></a> common to
all of mp++’s classes, <a class="reference internal" href="real.html#_CPPv4N4mppp4realE" title="mppp::real"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">real</span></code></a> features additional
specialised constructors:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">real</span><span class="w"> </span><span class="n">x0</span><span class="p">{</span><span class="n">real_kind</span><span class="o">::</span><span class="n">inf</span><span class="p">,</span><span class="w"> </span><span class="mi">-1</span><span class="p">,</span><span class="w"> </span><span class="mi">64</span><span class="p">};</span><span class="w"> </span><span class="c1">// x0 is set to -infinity with 64</span>
<span class="w">                                 </span><span class="c1">// bits of precision.</span>

<span class="n">real</span><span class="w"> </span><span class="n">x1</span><span class="p">{</span><span class="mi">-4</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="mi">112</span><span class="p">};</span><span class="w">             </span><span class="c1">// x1 is set to -4*2**8 with 112</span>
<span class="w">                                 </span><span class="c1">// bits of precision.</span>
</pre></div>
</div>
<p>Sometimes it is useful to be able to set a <a class="reference internal" href="real.html#_CPPv4N4mppp4realE" title="mppp::real"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">real</span></code></a>
to a specific value <em>without</em> changing its precision. For this
purpose, <a class="reference internal" href="real.html#_CPPv4N4mppp4realE" title="mppp::real"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">real</span></code></a> provides the <a class="reference internal" href="real.html#_CPPv4N4mppp4real3setERK4real" title="mppp::real::set"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">set()</span></code></a>
family of functions:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">real</span><span class="w"> </span><span class="n">x0</span><span class="p">{</span><span class="n">real_kind</span><span class="o">::</span><span class="n">zero</span><span class="p">,</span><span class="w"> </span><span class="mi">112</span><span class="p">};</span><span class="w"> </span><span class="c1">// Create a positive zero with 112 bits of precision.</span>

<span class="n">real</span><span class="w"> </span><span class="n">x1</span><span class="p">{</span><span class="s">&quot;1.1&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">256</span><span class="p">};</span><span class="w">           </span><span class="c1">// x1 is the 256-bit approximation of &#39;1.1&#39;.</span>
<span class="n">x0</span><span class="p">.</span><span class="n">set</span><span class="p">(</span><span class="n">x1</span><span class="p">);</span><span class="w">                    </span><span class="c1">// x0 will be set to x1 rounded to nearest</span>
<span class="w">                               </span><span class="c1">// to 112 bits.</span>

<span class="n">x0</span><span class="p">.</span><span class="n">set</span><span class="p">(</span><span class="mi">2</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">3</span><span class="n">_q1</span><span class="p">);</span><span class="w">              </span><span class="c1">// x0 will be set to the 112-bit approximation</span>
<span class="w">                               </span><span class="c1">// of the fraction &#39;2/3&#39;.</span>

<span class="n">x0</span><span class="p">.</span><span class="n">set</span><span class="p">(</span><span class="s">&quot;2.1&quot;</span><span class="p">);</span><span class="w">                 </span><span class="c1">// x0 will be set to the 112-bit approximation</span>
<span class="w">                               </span><span class="c1">// of the value &#39;2.1&#39;.</span>
</pre></div>
</div>
<p>Specialised setter functions are also available:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">real</span><span class="w"> </span><span class="n">x0</span><span class="p">{</span><span class="n">real_kind</span><span class="o">::</span><span class="n">zero</span><span class="p">,</span><span class="w"> </span><span class="mi">112</span><span class="p">};</span><span class="w"> </span><span class="c1">// Create a positive zero with 112 bits of precision.</span>

<span class="n">x0</span><span class="p">.</span><span class="n">set_inf</span><span class="p">();</span><span class="w">                  </span><span class="c1">// Set x0 to +infinity, precision is not altered.</span>
<span class="n">x0</span><span class="p">.</span><span class="n">set_inf</span><span class="p">(</span><span class="mi">-1</span><span class="p">);</span><span class="w">                </span><span class="c1">// Set x0 to -infinity, precision is not altered.</span>

<span class="n">set_ui_2exp</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">-5</span><span class="p">);</span><span class="w">        </span><span class="c1">// Set x0 to the 112-bit approximation of</span>
<span class="w">                               </span><span class="c1">// 4*2**(-5).</span>
</pre></div>
</div>
</section>
<section id="precision-propagation">
<h2>Precision propagation<a class="headerlink" href="#precision-propagation" title="Permalink to this headline">#</a></h2>
<p>In the C++ language, mixed-precision floating-point operations promote the lower-precision operand
to the higher-precision type. For instance, in the following code snippet,</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">float</span><span class="w"> </span><span class="n">x1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="kt">double</span><span class="w"> </span><span class="n">x2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"></span>

<span class="k">auto</span><span class="w"> </span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">x2</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>the addition is computed in <code class="docutils literal notranslate"><span class="pre">double</span></code> precision, and the result <code class="docutils literal notranslate"><span class="pre">ret</span></code>
will be of type <code class="docutils literal notranslate"><span class="pre">double</span></code>.</p>
<p><a class="reference internal" href="real.html#_CPPv4N4mppp4realE" title="mppp::real"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">real</span></code></a> adopts a similar principle: in functions (including
overloaded operators) accepting two or more <a class="reference internal" href="real.html#_CPPv4N4mppp4realE" title="mppp::real"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">real</span></code></a> arguments
in input, the precision at which the operation is performed (and the precision of the result)
is the maximum precision among the operands.</p>
<p>Let’s see a couple of examples:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">real</span><span class="w"> </span><span class="n">x1</span><span class="p">{</span><span class="s">&quot;1.1&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">128</span><span class="p">};</span><span class="w">          </span><span class="c1">// 128-bit approximation of &#39;1.1&#39;.</span>
<span class="n">real</span><span class="w"> </span><span class="n">x2</span><span class="p">{</span><span class="mi">42</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">};</span><span class="w">              </span><span class="c1">// x2 contains the value 42, represented exactly</span>
<span class="w">                              </span><span class="c1">// by a 10-bit significand.</span>

<span class="k">auto</span><span class="w"> </span><span class="n">x3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">x2</span><span class="p">;</span><span class="w">            </span><span class="c1">// x3 is the result of the addition of</span>
<span class="w">                              </span><span class="c1">// x1 and x2, computed at 128 bits of precision.</span>
<span class="n">assert</span><span class="p">(</span><span class="n">x3</span><span class="p">.</span><span class="n">get_prec</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">128</span><span class="p">);</span><span class="w"></span>

<span class="n">real</span><span class="w"> </span><span class="n">x4</span><span class="p">{</span><span class="s">&quot;2.3&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">256</span><span class="p">};</span><span class="w">          </span><span class="c1">// 256-bit approximation of &#39;2.3&#39;.</span>

<span class="k">auto</span><span class="w"> </span><span class="n">x5</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pow</span><span class="p">(</span><span class="n">x3</span><span class="p">,</span><span class="w"> </span><span class="n">x4</span><span class="p">);</span><span class="w">        </span><span class="c1">// x5 is the result of x3 raised to the</span>
<span class="w">                              </span><span class="c1">// power of x4, computed at 256 bits of precision.</span>
<span class="n">assert</span><span class="p">(</span><span class="n">x5</span><span class="p">.</span><span class="n">get_prec</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">256</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>The same idea extends to operations mixing <a class="reference internal" href="real.html#_CPPv4N4mppp4realE" title="mppp::real"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">real</span></code></a> and
non-<a class="reference internal" href="real.html#_CPPv4N4mppp4realE" title="mppp::real"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">real</span></code></a> types, where the “precision” of
non-<a class="reference internal" href="real.html#_CPPv4N4mppp4realE" title="mppp::real"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">real</span></code></a> types
is determined following a set of heuristics detailed in the documentation
of the generic constructor of <a class="reference internal" href="real.html#_CPPv4N4mppp4realE" title="mppp::real"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">real</span></code></a>.</p>
<p>Let’s see a few concrete examples:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">real</span><span class="w"> </span><span class="n">x1</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">};</span><span class="w">                   </span><span class="c1">// 4-bit representation of the value &#39;1&#39;.</span>

<span class="k">auto</span><span class="w"> </span><span class="n">x2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">41</span><span class="p">;</span><span class="w">               </span><span class="c1">// The deduced precision of the literal &#39;41&#39; is the</span>
<span class="w">                                 </span><span class="c1">// bit width of the &#39;int&#39; type (typically 32). Hence,</span>
<span class="w">                                 </span><span class="c1">// the addition will be performed with 32 bits of</span>
<span class="w">                                 </span><span class="c1">// precision (because 32 &gt; 4).</span>
<span class="n">assert</span><span class="p">(</span><span class="n">x2</span><span class="p">.</span><span class="n">get_prec</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">32</span><span class="p">);</span><span class="w"></span>

<span class="k">auto</span><span class="w"> </span><span class="n">x3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pow</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span><span class="w"> </span><span class="mf">0.5</span><span class="p">);</span><span class="w">          </span><span class="c1">// The deduced precision of the literal &#39;0.5&#39; is the</span>
<span class="w">                                 </span><span class="c1">// bit width of the significand of the &#39;double&#39; type</span>
<span class="w">                                 </span><span class="c1">// (typically 53). Hence, the exponentiation will be</span>
<span class="w">                                 </span><span class="c1">// performed with 53 bits of precision (because 53 &gt; 32).</span>
<span class="n">assert</span><span class="p">(</span><span class="n">x3</span><span class="p">.</span><span class="n">get_prec</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">53</span><span class="p">);</span><span class="w"></span>

<span class="k">auto</span><span class="w"> </span><span class="n">x4</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">atan2</span><span class="p">(</span><span class="n">real128</span><span class="p">{</span><span class="mi">2</span><span class="p">},</span><span class="w"> </span><span class="n">x3</span><span class="p">);</span><span class="w"> </span><span class="c1">// The deduced precision of a real128</span>
<span class="w">                                 </span><span class="c1">// is 113 (i.e., the number of bits in the</span>
<span class="w">                                 </span><span class="c1">// significand). Hence, the inverse tangent</span>
<span class="w">                                 </span><span class="c1">// will be computed with 113 bits of</span>
<span class="w">                                 </span><span class="c1">// precision (because 113 &gt; 53).</span>
<span class="n">assert</span><span class="p">(</span><span class="n">x4</span><span class="p">.</span><span class="n">get_prec</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">113</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="move-awareness">
<h2>Move awareness<a class="headerlink" href="#move-awareness" title="Permalink to this headline">#</a></h2>
<p>One of the major sources of inefficiency when working with <a class="reference internal" href="real.html#_CPPv4N4mppp4realE" title="mppp::real"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">real</span></code></a> objects,
especially at lower precisions, is the memory allocation overhead. The problem is
particularly evident when creating complex mathematical expressions involving
<a class="reference internal" href="real.html#_CPPv4N4mppp4realE" title="mppp::real"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">real</span></code></a> objects.</p>
<p>Consider the following example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">real</span><span class="w"> </span><span class="nf">horner_6</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">real</span><span class="w"> </span><span class="o">&amp;</span><span class="n">x</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="n">real</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="n">real</span><span class="p">{</span><span class="mf">1.</span><span class="p">},</span><span class="w"> </span><span class="n">real</span><span class="p">{</span><span class="mf">2.</span><span class="p">},</span><span class="w"> </span><span class="n">real</span><span class="p">{</span><span class="mf">3.</span><span class="p">},</span><span class="w"> </span><span class="n">real</span><span class="p">{</span><span class="mf">4.</span><span class="p">},</span><span class="w"> </span><span class="n">real</span><span class="p">{</span><span class="mf">5.</span><span class="p">},</span><span class="w"> </span><span class="n">real</span><span class="p">{</span><span class="mf">6.</span><span class="p">},</span><span class="w"> </span><span class="n">real</span><span class="p">{</span><span class="mf">7.</span><span class="p">}};</span><span class="w"></span>

<span class="w">   </span><span class="k">return</span><span class="w"> </span><span class="p">(((((</span><span class="n">a</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="mi">4</span><span class="p">])</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>This is the evaluation of the polynomial of degree 6</p>
<div class="math notranslate nohighlight">
\[1 + 2x + 3x^3 + 4x^3 + 5x^4 + 6x^5 + 7x^6\]</div>
<p>for some <a class="reference internal" href="real.html#_CPPv4N4mppp4realE" title="mppp::real"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">real</span></code></a> <span class="math notranslate nohighlight">\(x\)</span> via
<a class="reference external" href="https://en.wikipedia.org/wiki/Horner%27s_method">Horner’s method</a>.
The polynomial coefficients are stored in the array <code class="docutils literal notranslate"><span class="pre">a</span></code>.
Let’s focus on the expression in the return statement:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="p">(((((</span><span class="n">a</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="mi">4</span><span class="p">])</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"></span>
</pre></div>
</div>
<p>Due to the way operators are parsed in the C++ language,
this expression is decomposed in multiple subexpressions,
which are then formally chained together in the following fashion:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">auto</span><span class="w"> </span><span class="n">tmp0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="k">auto</span><span class="w"> </span><span class="n">tmp1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tmp0</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span><span class="w"></span>
<span class="k">auto</span><span class="w"> </span><span class="n">tmp2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tmp1</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="k">auto</span><span class="w"> </span><span class="n">tmp3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tmp2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span><span class="w"></span>
<span class="c1">// ... and so on.</span>
</pre></div>
</div>
<p>In other words, the evaluation of the expression above results
in the creation of 12 temporary <a class="reference internal" href="real.html#_CPPv4N4mppp4realE" title="mppp::real"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">real</span></code></a> objects. It’s easy
to see that the creation of these temporary variables is not really
necessary if one, instead of using overloaded binary operators,
employs either the ternary mathematical primitives provided by
<a class="reference internal" href="real.html#_CPPv4N4mppp4realE" title="mppp::real"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">real</span></code></a>, or, equivalently, in-place operators:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Create the return value.</span>
<span class="n">real</span><span class="w"> </span><span class="n">ret</span><span class="p">{</span><span class="n">a</span><span class="p">[</span><span class="mi">6</span><span class="p">]};</span><span class="w"></span>

<span class="c1">// Accumulate the result into</span>
<span class="c1">// ret step-by-step.</span>
<span class="n">mul</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span><span class="w"> </span><span class="n">ret</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">);</span><span class="w">    </span><span class="c1">// or: ret *= x;</span>
<span class="n">add</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span><span class="w"> </span><span class="n">ret</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="mi">5</span><span class="p">]);</span><span class="w"> </span><span class="c1">// or: ret += a[5];</span>
<span class="n">mul</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span><span class="w"> </span><span class="n">ret</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">);</span><span class="w">    </span><span class="c1">// or: ret *= x;</span>
<span class="n">add</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span><span class="w"> </span><span class="n">ret</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="mi">4</span><span class="p">]);</span><span class="w"> </span><span class="c1">// or: ret += a[4];</span>
<span class="c1">// ... and so on.</span>
</pre></div>
</div>
<p>While this approach is valid and efficient, it is quite verbose,
and, arguably, code clarity suffers.</p>
<p>Luckily, it turns out that such a complication is not really necessary,
because all the operators and functions in the <a class="reference internal" href="real.html#_CPPv4N4mppp4realE" title="mppp::real"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">real</span></code></a>
API are <em>move-aware</em>. This means that the real API is able to detect
when a <a class="reference internal" href="real.html#_CPPv4N4mppp4realE" title="mppp::real"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">real</span></code></a> argument is a temporary (technically,
an <em>rvalue</em>) and it is able to re-use the memory provided by such
a temporary to construct the result of the operation.</p>
<p>For instance, consider the subexpression:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">a</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="w"></span>
</pre></div>
</div>
<p>Here the multiplication <code class="docutils literal notranslate"><span class="pre">a[6]</span> <span class="pre">*</span> <span class="pre">x</span></code> produces a new <a class="reference internal" href="real.html#_CPPv4N4mppp4realE" title="mppp::real"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">real</span></code></a>, which
is then added to <code class="docutils literal notranslate"><span class="pre">a[5]</span></code>. The binary addition operator of <a class="reference internal" href="real.html#_CPPv4N4mppp4realE" title="mppp::real"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">real</span></code></a>
recognises that the first argument is an rvalue, and accordingly it will use the
memory provided by the result of <code class="docutils literal notranslate"><span class="pre">a[6]</span> <span class="pre">*</span> <span class="pre">x</span></code> to create the result of the full
subexpression, thus avoiding an unnecessary memory allocation.</p>
<p>The end result is that in the expression</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="p">(((((</span><span class="n">a</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="mi">4</span><span class="p">])</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"></span>
</pre></div>
</div>
<p>only a <strong>single</strong> memory allocation is performed, instead of 12.</p>
<p>Moreover, it turns out that in this specific case it is even possible to elide that
last memory allocation. Observe that in the expression above, the only memory
allocation originates from the first subexpression encountered by the compiler, that is:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">a</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">x</span><span class="w"></span>
</pre></div>
</div>
<p>In this subexpression there are no rvalues whose memory can be pilfered. However, we can notice how the variable
<code class="docutils literal notranslate"><span class="pre">a[6]</span></code> from the coefficient array is never used again in the rest of the <code class="docutils literal notranslate"><span class="pre">horner_6()</span></code>
function. We can then “cast” <code class="docutils literal notranslate"><span class="pre">a[6]</span></code> to an rvalue via the <code class="docutils literal notranslate"><span class="pre">std::move()</span></code> utility function:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">6</span><span class="p">])</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">x</span><span class="w"></span>
</pre></div>
</div>
<p>Now the memory necessary to represent the result of the multiplication will be “stolen” from
<code class="docutils literal notranslate"><span class="pre">a[6]</span></code>. We have thus avoided the last remaining memory allocation.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Extreme care must be taken when using manually <code class="docutils literal notranslate"><span class="pre">std::move()</span></code> on a <a class="reference internal" href="real.html#_CPPv4N4mppp4realE" title="mppp::real"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">real</span></code></a>
object. Only a very narrow set of operations is valid on a moved-from <a class="reference internal" href="real.html#_CPPv4N4mppp4realE" title="mppp::real"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">real</span></code></a>
(see the documentation of the move constructor), and any other operation will result
in undefined behaviour.</p>
<p>Generally speaking, use-after-move is considered a pattern to
avoid in modern C++. Static analysis tools such as <a class="reference external" href="https://clang.llvm.org/extra/clang-tidy/">clang-tidy</a>
are very effective at detecting use-after-move occurrences in source code.</p>
</div>
<p>It is important to emphasise how move-awareness in the <a class="reference internal" href="real.html#_CPPv4N4mppp4realE" title="mppp::real"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">real</span></code></a> API is not
limited to mathematical operators: all functions accepting one or more <a class="reference internal" href="real.html#_CPPv4N4mppp4realE" title="mppp::real"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">real</span></code></a>
objects as input arguments are move-aware.</p>
</section>
<section id="special-functions">
<h2>Special functions<a class="headerlink" href="#special-functions" title="Permalink to this headline">#</a></h2>
<p>One of the design goals of the <a class="reference internal" href="real.html#_CPPv4N4mppp4realE" title="mppp::real"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">real</span></code></a> class is to provide a
comprehensive library of special functions. <a class="reference internal" href="real.html#_CPPv4N4mppp4realE" title="mppp::real"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">real</span></code></a> currently
wraps all the special functions provided by the MPFR library, including:</p>
<ul class="simple">
<li><p>roots and exponentiation,</p></li>
<li><p>(inverse) trigonometric functions,</p></li>
<li><p>(inverse) hyperbolic functions,</p></li>
<li><p>logarithms and exponentials,</p></li>
<li><p>Gamma functions,</p></li>
<li><p>Bessel functions,</p></li>
<li><p>error functions,</p></li>
</ul>
<p>and many more. Additionally, <a class="reference internal" href="real.html#_CPPv4N4mppp4realE" title="mppp::real"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">real</span></code></a> can also (optionally) use
the <a class="reference external" href="https://arblib.org/">Arb</a> library to provide additional special functions
not available in MPFR.</p>
</section>
<section id="constants">
<h2>Constants<a class="headerlink" href="#constants" title="Permalink to this headline">#</a></h2>
<p>The MPFR API provides the ability to compute a handful of
constants in arbitrary precision. This capability is
<a class="reference internal" href="real.html#real-constants"><span class="std std-ref">exposed</span></a>
in the <a class="reference internal" href="real.html#_CPPv4N4mppp4realE" title="mppp::real"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">real</span></code></a> API. Here’s an example
with the <span class="math notranslate nohighlight">\(\pi\)</span> constant:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">real</span><span class="w"> </span><span class="n">r0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">real_pi</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span><span class="w">        </span><span class="c1">// r0 is the 42-bit approximation of pi,</span>
<span class="w">                              </span><span class="c1">// that is, 3.14159265359012.</span>

<span class="n">real</span><span class="w"> </span><span class="n">r1</span><span class="p">{</span><span class="n">real_kind</span><span class="o">::</span><span class="n">zero</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">};</span><span class="w"> </span><span class="c1">// Init a real zero with 10 bits of precision.</span>

<span class="n">real_pi</span><span class="p">(</span><span class="n">r1</span><span class="p">);</span><span class="w">                  </span><span class="c1">// r1 is now set to the 10-bit approximation of</span>
<span class="w">                              </span><span class="c1">// pi, that is, 3.1406.</span>
</pre></div>
</div>
</section>
<section id="comparisons">
<h2>Comparisons<a class="headerlink" href="#comparisons" title="Permalink to this headline">#</a></h2>
<p>In addition to the <a class="reference internal" href="tutorial_commonops.html#tutorial-commonops"><span class="std std-ref">common comparison operators</span></a>
available for all of mp++’s multiprecision classes,
<a class="reference internal" href="real.html#_CPPv4N4mppp4realE" title="mppp::real"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">real</span></code></a> supports additional comparison functions.</p>
<p>For instance, it is possible to detect special <a class="reference internal" href="real.html#_CPPv4N4mppp4realE" title="mppp::real"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">real</span></code></a> values:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Check that default construction</span>
<span class="c1">// initialises to zero.</span>
<span class="n">real</span><span class="w"> </span><span class="n">r0</span><span class="p">;</span><span class="w"></span>
<span class="n">assert</span><span class="p">(</span><span class="n">r0</span><span class="p">.</span><span class="n">zero_p</span><span class="p">());</span><span class="w"></span>

<span class="c1">// Detection of non-finite values.</span>
<span class="n">real</span><span class="w"> </span><span class="n">r1</span><span class="p">{</span><span class="s">&quot;inf&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">42</span><span class="p">};</span><span class="w"></span>
<span class="n">assert</span><span class="p">(</span><span class="n">r1</span><span class="p">.</span><span class="n">inf_p</span><span class="p">());</span><span class="w"></span>
<span class="n">real</span><span class="w"> </span><span class="n">r2</span><span class="p">{</span><span class="s">&quot;nan&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">42</span><span class="p">};</span><span class="w"></span>
<span class="n">assert</span><span class="p">(</span><span class="n">r2</span><span class="p">.</span><span class="n">nan_p</span><span class="p">());</span><span class="w"></span>

<span class="c1">// Check if a real is an exact</span>
<span class="c1">// integral value.</span>
<span class="n">real</span><span class="w"> </span><span class="n">r3</span><span class="p">{</span><span class="mi">3</span><span class="p">};</span><span class="w"></span>
<span class="n">assert</span><span class="p">(</span><span class="n">r3</span><span class="p">.</span><span class="n">integer_p</span><span class="p">());</span><span class="w"></span>
</pre></div>
</div>
<p><a class="reference internal" href="real.html#_CPPv4N4mppp4realE" title="mppp::real"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">real</span></code></a> values can be compared by absolute value:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">assert</span><span class="p">(</span><span class="n">cmpabs</span><span class="p">(</span><span class="n">real</span><span class="p">{</span><span class="mi">1</span><span class="p">},</span><span class="w"> </span><span class="n">real</span><span class="p">{</span><span class="mi">-1</span><span class="p">})</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"> </span><span class="c1">// |1| == |-1|.</span>
<span class="n">assert</span><span class="p">(</span><span class="n">cmpabs</span><span class="p">(</span><span class="n">real</span><span class="p">{</span><span class="mi">-2</span><span class="p">},</span><span class="w"> </span><span class="n">real</span><span class="p">{</span><span class="mi">1</span><span class="p">})</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w">  </span><span class="c1">// |-2| &gt; |1|.</span>
<span class="n">assert</span><span class="p">(</span><span class="n">cmpabs</span><span class="p">(</span><span class="n">real</span><span class="p">{</span><span class="mi">0</span><span class="p">},</span><span class="w"> </span><span class="n">real</span><span class="p">{</span><span class="mi">-1</span><span class="p">})</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w">  </span><span class="c1">// |0| &lt; |-1|.</span>
</pre></div>
</div>
<p>And they can also be compared efficiently to integral multiples
of powers of 2:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">assert</span><span class="p">(</span><span class="n">cmp_ui_2exp</span><span class="p">(</span><span class="n">real</span><span class="p">{</span><span class="mi">50</span><span class="p">},</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"> </span><span class="c1">// 50 &gt; 3*2**4.</span>
</pre></div>
</div>
<p>The <a class="reference internal" href="real.html#_CPPv4N4mppp4realE" title="mppp::real"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">real</span></code></a> API also provides comparison
functions that handle NaN values in a special way. Specifically,
these functions consider all NaN values equal to each other
and greater than non-NaN values:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">assert</span><span class="p">(</span><span class="n">real_equal_to</span><span class="p">(</span><span class="n">real</span><span class="p">{</span><span class="s">&quot;nan&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">},</span><span class="w"> </span><span class="n">real</span><span class="p">{</span><span class="s">&quot;nan&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">20</span><span class="p">}));</span><span class="w"> </span><span class="c1">// NaN == NaN.</span>
<span class="n">assert</span><span class="p">(</span><span class="n">real_gt</span><span class="p">(</span><span class="n">real</span><span class="p">{</span><span class="s">&quot;nan&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">},</span><span class="w"> </span><span class="n">real</span><span class="p">{</span><span class="mi">100</span><span class="p">}));</span><span class="w">             </span><span class="c1">// NaN &gt; 100.</span>
<span class="n">assert</span><span class="p">(</span><span class="n">real_lt</span><span class="p">(</span><span class="n">real</span><span class="p">{</span><span class="s">&quot;inf&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">20</span><span class="p">},</span><span class="w"> </span><span class="n">real</span><span class="p">{</span><span class="s">&quot;nan&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">}));</span><span class="w">       </span><span class="c1">// inf &lt; NaN.</span>
</pre></div>
</div>
</section>
<section id="interacting-with-the-mpfr-api">
<h2>Interacting with the MPFR API<a class="headerlink" href="#interacting-with-the-mpfr-api" title="Permalink to this headline">#</a></h2>
<p>Because <a class="reference internal" href="real.html#_CPPv4N4mppp4realE" title="mppp::real"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">real</span></code></a> wraps an <a class="reference internal" href="real.html#_CPPv46mpfr_t" title="mpfr_t"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">mpfr_t</span></code></a>
instance, it is trivial to use a <a class="reference internal" href="real.html#_CPPv4N4mppp4realE" title="mppp::real"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">real</span></code></a> in the MPFR API.
Two member functions are provided for direct access to the internal
<a class="reference internal" href="real.html#_CPPv46mpfr_t" title="mpfr_t"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">mpfr_t</span></code></a> instance:</p>
<ul class="simple">
<li><p><a class="reference internal" href="real.html#_CPPv4NK4mppp4real10get_mpfr_tEv" title="mppp::real::get_mpfr_t"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">mppp::real::get_mpfr_t()</span></code></a>, which returns a <code class="docutils literal notranslate"><span class="pre">const</span></code> <a class="reference internal" href="real.html#_CPPv46mpfr_t" title="mpfr_t"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">mpfr_t</span></code></a>,</p></li>
<li><p><a class="reference internal" href="real.html#_CPPv4N4mppp4real11_get_mpfr_tEv" title="mppp::real::_get_mpfr_t"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">mppp::real::_get_mpfr_t()</span></code></a>, which returns a mutable <a class="reference internal" href="real.html#_CPPv46mpfr_t" title="mpfr_t"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">mpfr_t</span></code></a>.</p></li>
</ul>
<p>When using <a class="reference internal" href="real.html#_CPPv4N4mppp4real11_get_mpfr_tEv" title="mppp::real::_get_mpfr_t"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">mppp::real::_get_mpfr_t()</span></code></a>, it is the user’s responsibility to ensure
that the internal <a class="reference internal" href="real.html#_CPPv46mpfr_t" title="mpfr_t"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">mpfr_t</span></code></a> is kept in a state which respects the invariants
of the <a class="reference internal" href="real.html#_CPPv4N4mppp4realE" title="mppp::real"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">real</span></code></a> class. Specifically, the precision value
must be in the bounds established by <a class="reference internal" href="real.html#_CPPv4N4mppp13real_prec_minEv" title="mppp::real_prec_min"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">mppp::real_prec_min()</span></code></a> and
<a class="reference internal" href="real.html#_CPPv4N4mppp13real_prec_maxEv" title="mppp::real_prec_max"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">mppp::real_prec_max()</span></code></a>, and, upon destruction, a <a class="reference internal" href="real.html#_CPPv4N4mppp4realE" title="mppp::real"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">real</span></code></a>
object must contain a valid <a class="reference internal" href="real.html#_CPPv46mpfr_t" title="mpfr_t"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">mpfr_t</span></code></a> object.</p>
<p>Additionally, a variety of constructors, assignment operators and setters from
<a class="reference internal" href="real.html#_CPPv46mpfr_t" title="mpfr_t"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">mpfr_t</span></code></a> are also available.</p>
</section>
<section id="serialisation">
<h2>Serialisation<a class="headerlink" href="#serialisation" title="Permalink to this headline">#</a></h2>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.22.</span></p>
</div>
<p>mp++ provides a simple <a class="reference internal" href="real.html#real-s11n"><span class="std std-ref">API for the (de)serialisation</span></a> of <a class="reference internal" href="real.html#_CPPv4N4mppp4realE" title="mppp::real"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">real</span></code></a> objects
into/from memory buffers and C++ streams. Possible uses of the serialisation API include persistence (e.g.,
saving/loading <a class="reference internal" href="real.html#_CPPv4N4mppp4realE" title="mppp::real"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">real</span></code></a> values to/from a file), the transmission of <a class="reference internal" href="real.html#_CPPv4N4mppp4realE" title="mppp::real"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">real</span></code></a> objects over
the network (e.g., in distributed computing applications), inter-process communication, etc. The API consists of two main
overloaded functions, <a class="reference internal" href="real.html#_CPPv4NK4mppp4real11binary_saveEPc" title="mppp::real::binary_save"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">mppp::real::binary_save()</span></code></a> and <a class="reference internal" href="real.html#_CPPv4N4mppp4real11binary_loadEPKc" title="mppp::real::binary_load"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">mppp::real::binary_load()</span></code></a> (plus their
free-function counterparts).</p>
<p>Because the API is identical, we refer to the tutorial section on
<a class="reference internal" href="tutorial_integer.html#tutorial-integer-s11n"><span class="std std-ref">integer serialisation</span></a> for usage examples.</p>
<p>As already pointed out in the <a class="reference internal" href="tutorial_integer.html#tutorial-integer-s11n"><span class="std std-ref">integer serialisation section</span></a>,
the following points must be emphasised:</p>
<ul class="simple">
<li><p>although mp++ does run some consistency checks during deserialisation, the API is not built to protect
against maliciously-crafted data. Users are thus advised not to load data from untrusted sources;</p></li>
<li><p>the current binary serialisation format is compiler, platform and architecture specific, it is not portable
and it might be subject to changes in future versions of mp++. Users are thus advised not to use
the binary serialisation format for long-term persistence or as a data exchange format: for such
purposes, it is better to use the string representation of <a class="reference internal" href="real.html#_CPPv4N4mppp4realE" title="mppp::real"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">real</span></code></a> objects.</p></li>
</ul>
</section>
<section id="user-defined-literals">
<h2>User-defined literals<a class="headerlink" href="#user-defined-literals" title="Permalink to this headline">#</a></h2>
<p>User-defined literals are available for <a class="reference internal" href="real.html#_CPPv4N4mppp4realE" title="mppp::real"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">real</span></code></a>.
The <a class="reference internal" href="real.html#real-literals"><span class="std std-ref">literals</span></a>
are defined within
the inline namespace <code class="docutils literal notranslate"><span class="pre">mppp::literals</span></code>, they support
decimal and hexadecimal representations, and they currently
allow to construct <a class="reference internal" href="real.html#_CPPv4N4mppp4realE" title="mppp::real"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">real</span></code></a> instances
with 128, 256, 512 and 1024 bits of precision:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">mppp</span><span class="o">::</span><span class="nn">literals</span><span class="p">;</span><span class="w"></span>

<span class="k">auto</span><span class="w"> </span><span class="n">r1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">123.456</span><span class="n">_r128</span><span class="p">;</span><span class="w">   </span><span class="c1">// r1 contains the 128-bit</span>
<span class="w">                          </span><span class="c1">// approximation of 123.456 (that is,</span>
<span class="w">                          </span><span class="c1">// 123.45599999999999999999999999999999999988).</span>

<span class="k">auto</span><span class="w"> </span><span class="n">r2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">4.2e1</span><span class="n">_r256</span><span class="p">;</span><span class="w">     </span><span class="c1">// Scientific notation can be used.</span>

<span class="k">auto</span><span class="w"> </span><span class="n">r3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0x1.12p-1</span><span class="n">_r512</span><span class="p">;</span><span class="w"> </span><span class="c1">// Hexadecimal floats are supported too.</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference external" href="https://en.cppreference.com/w/cpp/language/floating_literal">https://en.cppreference.com/w/cpp/language/floating_literal</a></p>
</div>
</section>
</section>


              </div>
              
            </main>
            <footer class="footer-article noprint">
                
    <!-- Previous / next buttons -->
<div class='prev-next-area'>
    <a class='left-prev' id="prev-link" href="tutorial_complex128.html" title="previous page">
        <i class="fas fa-angle-left"></i>
        <div class="prev-next-info">
            <p class="prev-next-subtitle">previous</p>
            <p class="prev-next-title">Quadruple-precision complex numbers tutorial</p>
        </div>
    </a>
    <a class='right-next' id="next-link" href="tutorial_complex.html" title="next page">
    <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">Multiprecision complex numbers tutorial</p>
    </div>
    <i class="fas fa-angle-right"></i>
    </a>
</div>
            </footer>
        </div>
    </div>
    <div class="footer-content row">
        <footer class="col footer"><p>
  
    By Francesco Biscani<br/>
  
      &copy; Copyright 2016-2021, Francesco Biscani.<br/>
</p>
        </footer>
    </div>
    
</div>


      </div>
    </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf"></script>


  </body>
</html>